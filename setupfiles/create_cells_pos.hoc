proc createCells(){ local i, ij, si, pci, cellind, runresult, gid	// Create cells and assign a GID to each cell
	for cellind=0, numCellTypes-1 {
		if (strcmp(cellType[cellind].cellType_string,"mossycell")==0) {	// Update the seed for the random # generators
			{usedseeds=noise_random_stream_offset_*(cellType[cellind].numCells+1)+1}	// Calculate which section(s) of the random
		}	else {
			usedseeds=1
		}																		//	number stream have already been used
		for pcitr(&i, &ij, &gid, cellType[cellind].cellStartGid, cellType[cellind].cellEndGid) {// use the pciter over all cells of this type
			if (pc.gid_exists(gid)) {
				sprint(cmd, "cellType[%g].CellList[%g]=new %s(%g)", cellind, ij, cellType[cellind].cellType_string, gid) //+cellType[cellind].cellStartGid) // why add the startgid to the gid? 
				//## printf("pc: %g, cmd: %s\n", pc.id, cmd)
				{runresult=execute1(cmd)} 		// This command was written as a string so
												//	the cell object doesn't have to be hard coded
				cells.append(cellType[cellind].CellList[ij])	// Append each cell to cells list
				
				ranconlist.append(new RandomStream(usedseeds, gid)) //+(gid*2*4)*random_stream_offset_))	// Create a new random number generator for each cell,
																	//	with a unique stream section defined by the starting location.  This
																	//	will be used to determine which connections are made
																	//  DO NOT let the highseed be 0, because BAD things will happen =(

				ranconlist.object(i).r.uniform(0,1)// Set up the generator to pick a uniform dist of numbers between 0 and 1
																	// int(gid/pc.nhost) gives the stream number on that host

				ransynlist.append(new RandomStream(usedseeds+(1+RandomSeeds)*random_stream_offset_+1, gid)) //+(gid*2+1)*random_stream_offset_))	// Create a new random number generator for each cell,
																								//	with a unique stream. This will be used to determine
																								//	what type of synapse is used in connections
				cellType[cellind].CellList[ij].connect_pre(nil, nc)	// Create an empty connection for use by the spike detector
				pc.cell(gid, nc)									// Associate the cell with its gid and its spike generation location
				
				if (cellind>0) {									// For non ppstim cells, assign position, initialize synapse cid and sid
					for si=0, cellType[cellind].CellList[ij].pre_list.count-1 {	// Iterate over each pre cell type's synapse list
						for j=0, cellType[cellind].CellList[ij].pre_list.o(si).count-1 {		// Iterate through each synapse in the list
							cellType[cellind].CellList[ij].pre_list.o(si).o(j).cid=gid			// Set the cell id for each synapse
																								//  Note: Parameters added to Syn2Gid mechanism
						}
					}
					xpos=xpos_algorithm(gid,cellType[cellind].numCells,cellType[cellind].cellStartGid,cellType[cellind].dentateXBins,cellType[cellind].dentateYBins*cellType[cellind].dentateZBins,cellType[cellind].dentateXBinSize)	// Algorithmically generate cell position
					ypos=ypos_algorithm(gid,cellType[cellind].numCells,cellType[cellind].cellStartGid,cellType[cellind].dentateYBins,cellType[cellind].dentateZBins,cellType[cellind].dentateYBinSize)	// Algorithmically generate cell position
					zpos=zpos_algorithm(gid,cellType[cellind].numCells,cellType[cellind].cellStartGid,cellType[cellind].dentateZBins,cellType[cellind].dentateZBinSize,cellType[cellind].layerflag)	// Algorithmically generate cell position
					cellType[cellind].CellList[ij].position(xpos,ypos,zpos)									// Record cell position in cell object
					
					if ((ij%int(cellType[cellind].numCells/10+1) == 0) && (PrintTerminal>1)) {print cellType[cellind].cellType_string, ": ", i}
				}
			}
		} 
	}

	nc = nil // Then clear the reference to the netcon object, which should destroy the netcon (because all refs would have been removed)
	if  (PrintTerminal>0) {print "Host ", pc.id, " created cells."}
}
createCells()
